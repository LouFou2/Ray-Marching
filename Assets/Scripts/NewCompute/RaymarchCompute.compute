// RaymarchCompute.compute
#pragma kernel CSMain
#pragma kernel UpdateSpheres
#include "UnityCG.cginc"

struct SphereData
{
    float4 sphereInfo; // xyz = position, w = radius
};

RWStructuredBuffer<SphereData> _Spheres;
int _SphereCount;
float segmentLength; // for capsule shapes => distance between points/spheres

float4x4 _CamFrustum;   // rows: 0=TL,1=TR,2=BR,3=BL (as your C# builds it)
float4x4 _CamToWorld;   // camera to world matrix
float3 _CameraPos;
float _MaxDistance;

TextureCube<float4> _SkyBoxCubeMap;
SamplerState _LinearClamp; // Or other sampler state

RWTexture2D<float4> _Result; // output
float2 _Resolution;          // width, height (set from C#)

float time;
//float PI = 3.14159265359;

//===================
// Helper functions
//===================

float myInverseLerp(float a, float b, float t)
{
    return saturate((t-a)/(b-a));
}
// from: https://iquilezles.org/articles/smoothsteps/
float smoothstep( float x )
{
  return x*x*(2.0-x*x);
}

//===================
// Distance functions
//===================

float sdSphere(float3 p, float s)
{
    return length(p) - s;
}


float sdCapsule(float3 p, float3 a, float3 b, float ra, float rb)
{
    float3 pa = p-a;
    float3 ba = b-a;
    float h = saturate(dot(pa, ba)/dot(ba, ba)); //the h value is like an inverse lerp from 0 to 1 across the length of the cylinder

    float r = lerp(ra, rb, h);

    //(*#* this section is irrelevant, as the radius gets calculated across the whole chain, but it is a useful reference) :
    /*
    if(_SphereCount == 2)
    {
        //=== modifying the radius === 
        float falloffFactor = myInverseLerp(r*2, segmentLength, length(ba));

        float parabolic = 1 - pow(3.98 * h * (1.0 - h), 2.2); // a parabolic function "3.98" was 4.0, it changes the thin min. "2.2" was 2, it changes the start/end of curve
        float falloff = clamp(smoothstep(1-h), 0.33, 1); // 0.3 here is the min radius of the "tip"
    
        // the closer together the points, the less the effect of the parabola
        float radiusStretch = r * parabolic * falloff;
        //float combined = radiusStretch * falloff;
        r = lerp(ra, radiusStretch, falloffFactor);
    }
    */ 
    //*#*

    //what I CAN do though, is add a bit of noise or distortion:
    float PI = 3.14159265359;

    //r = r + sin(h * PI * 2) * (r * 0.2);

    float d = length(pa - ba * h) - r;
    d = d + sin(h * PI * 4) * (r * 0.2);
    
    return d;
}

float smoothUnion(float distA, float distB, float strength)
{
    float h = clamp(0.5 + 0.5 * (distB - distA) / strength, 0.0, 1.0);
    return lerp(distB, distA, h) - strength * h * (1.0 - h);
}

float opUnion(float distA, float distB) // not sure why this isnt working
{
    return min(distA, distB);
}


float distanceField(float3 p)
{
    float d = 1e6;
    float totalChainLength = segmentLength * (_SphereCount - 1);

    if(_SphereCount == 1) d = sdSphere(p - _Spheres[0].sphereInfo.xyz, _Spheres[0].sphereInfo.w);

    if(_SphereCount > 1)
    {
        for (int i = _SphereCount - 1; i > 0 ; i--)
        {
            // positions
            float3 current = _Spheres[i].sphereInfo.xyz;
            float3 next = _Spheres[i-1].sphereInfo.xyz;
            float currentRad = _Spheres[i].sphereInfo.w;
            float nextRad = _Spheres[i-1].sphereInfo.w;

            // radii
            // Falloff curve across the full chain length
            float interpRadiusFactorA = myInverseLerp(0, totalChainLength, i * segmentLength ); // gives a 0 to 1 value. _SphereCount-1 is the segment count
            if(_SphereCount == 2) interpRadiusFactorA = 1; // special case if only 2 points
            float smoothA = clamp(smoothstep(interpRadiusFactorA), 0.16, 1); // 0.16 here is just an arbitrary minimum, adjust appropriately (same below (*) )

            float interpRadiusFactorB = myInverseLerp(0, totalChainLength, (i-1) * segmentLength );
            if(_SphereCount == 2) interpRadiusFactorB = 1- myInverseLerp(0, segmentLength, length(current-next)); // special case if only 2 points
            float smoothB = clamp(smoothstep(interpRadiusFactorB), 0.16, 1); // (*)

            // parabolic curve
            // how much the parabolic effect applies depends on how straight the chain is.. like it's "stretched out"
            // so we need to check the distance between start and end point vs. the total chain length
            float parabolicFactor = myInverseLerp(0, totalChainLength, length(_Spheres[_SphereCount-1].sphereInfo.xyz - _Spheres[0].sphereInfo.xyz)); //0 no par, 1 = full par

            float parabolicA = 1 - pow(3.98 * interpRadiusFactorA * (1.0 - interpRadiusFactorA), 2.2) * parabolicFactor; // a parabolic function "3.98" was 4.0, it changes the thin min. "2.2" was 2, it changes the start/end of curve
            float parabolicB = 1 - pow(3.98 * interpRadiusFactorB * (1.0 - interpRadiusFactorB), 2.2) * parabolicFactor;
            
            float smoothParabA = currentRad * parabolicA * smoothA;
            float smoothParabB = nextRad * parabolicB * smoothB;

            float avRad = (smoothParabA + smoothParabB) * 0.5;

            if (length(next-current) <= avRad) // if they are close enough they should be spheres
            {
                float sphere1 = sdSphere(p - current, smoothParabA);
                float sphere2 = sdSphere(p - next, smoothParabB);
                float joined = smoothUnion(sphere1, sphere2, avRad * 0.5);
                d = smoothUnion(d, joined, avRad  * 0.5);
            }
            else
            {
                float capsule = sdCapsule(p, current, next, smoothParabA, smoothParabB);
                d = smoothUnion(d, capsule, smoothParabB * 0.1); // smooth union just takes away visible joint seams

                // *** IF I WANNA SWITCH TO SPHERES INSTEAD OF CAPSULES:
                // will need to dynamically set distances between spheres based on each updated radius
                //float sphere1 = sdSphere(p - current, smoothParabA);
                //float sphere2 = sdSphere(p - next, smoothParabB);
                //float joined = smoothUnion(sphere1, sphere2, avRad * 0.5);
                //d = smoothUnion(d, joined, avRad  * 0.5);
            }
        }
    }

    return d;
}

float3 getNormal(float3 p)
{
    const float2 e = float2(0.001, 0);
    float3 n = float3(
        distanceField(p + e.xyy) - distanceField(p - e.xyy),
        distanceField(p + e.yxy) - distanceField(p - e.yxy),
        distanceField(p + e.yyx) - distanceField(p - e.yyx)
    );
    return normalize(n);
}

float fresnel(float3 n, float3 rd)
{
    float d = 1 - saturate(abs(dot(n, rd)));
    return d;
}

//=====================
// Fluidity functions
//=====================

float3 fluidFollowPos(float3 leadPos, float3 followPos)// was previously also using: ..., float leadRad, float followRad)*
{
    // difference vector
    float3 diff = leadPos - followPos;
    float3 dir = normalize(diff);
    float3 dist = length(diff);

    // move fractionally toward leader each frame
    float smoothTime = 5.0;   // adjust as needed
    float3 newPos = followPos;
    
    //float distBetweenSpheres = leadRad + followRad; //* see old below

    // just a damped follow - keeping the distance between the spheres
    if(distance(leadPos, followPos) > segmentLength) // *old: if(distance(leadPos, followPos) > distBetweenSpheres * 5)
    {
        newPos = followPos + diff * (1.0 - exp(-smoothTime * time)); 
    }

    return newPos;
}
//======================
// Sphere Update Kernel (for fluid relationships between points)
//======================

[numthreads(1,1,1)]
void UpdateSpheres(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i == 0 || i >= _SphereCount) return;

    float3 leaderPos = _Spheres[i].sphereInfo.xyz;
    float3 followerPos = _Spheres[i-1].sphereInfo.xyz;
    //float leaderRadius = _Spheres[i].sphereInfo.w;
    //float followerRadius = _Spheres[i-1].sphereInfo.w;

    float3 newPos = fluidFollowPos(leaderPos, followerPos); // previously also used ..., leaderRadius, followerRadius);
    _Spheres[i-1].sphereInfo.xyz = newPos;
}

//================
// Compute kernel
//================

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // bounds check using resolution passed from C#
    if (id.x >= (uint)_Resolution.x || id.y >= (uint)_Resolution.y) return;

    // pixel-centered UV [0..1]
    float2 pixel = float2(id.xy) + 0.5;
    float2 uv = pixel / _Resolution;

    // flip Y because RWTexture2D indexing is origin top-left vs UV origin bottom-left
    uv.y = 1.0 - uv.y;

    // Interpolate ray direction across the frustum corners
    // read frustum rows (each row is a float4 where .xyz is a direction)
    float3 TL = _CamFrustum[0].xyz;
    float3 TR = _CamFrustum[1].xyz;
    float3 BR = _CamFrustum[2].xyz;
    float3 BL = _CamFrustum[3].xyz;

    // Interpolate horizontally across top and bottom, then vertically between them
    float3 top = lerp(TL, TR, uv.x);
    float3 bottom = lerp(BL, BR, uv.x);
    float3 rayView = lerp(top, bottom, uv.y);

    // Normalize and transform direction to world space
    rayView = normalize(rayView);
    float3 rayDir = normalize( mul(_CamToWorld, float4(rayView, 0)).xyz );

    float3 rayOrigin = _CameraPos;

    float4 bgColor = _SkyBoxCubeMap.SampleLevel(_LinearClamp, rayDir, 0);

    // Raymarch
    float3 col = float3(0,0,0);
    const int MAX_STEPS = 128;
    float t = 0.0;

    for (int i = 0; i < MAX_STEPS; i++)
    {
        if (t > _MaxDistance)
        {
            //col = abs(rayDir); // show direction as RGB (use abs to keep it positive)
            col = bgColor.xyz;
            break;
        }

        float3 p = rayOrigin + rayDir * t;
        float d = distanceField(p);

        if (d < 0.001)
        {
            float3 n = getNormal(p);
            float f = fresnel(n, rayDir);
            float4 reflectCol = _SkyBoxCubeMap.SampleLevel(_LinearClamp, n, 0);
            reflectCol = saturate(pow(reflectCol, 2.0));

            float3 basicCol = float3(0, 0, 0);

            float3 lerpedCol = lerp(basicCol, reflectCol, f);

            col = lerpedCol;
            break;
        }

        // Avoid infinite loop if distanceField returns negative or zero unexpectedly.
        t += max(d, 1e-5);
    }

    _Result[int2(id.xy)] = float4(col, 1.0);
}
