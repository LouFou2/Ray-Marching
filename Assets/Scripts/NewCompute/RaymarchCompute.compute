// RaymarchCompute.compute
#pragma kernel CSMain
#pragma kernel UpdatePoints
#include "UnityCG.cginc"

struct PointData
{
    float4 pointPos_Radius; // xyz = position, w = radius
    float4 pointVelocity_pad; // xyz  = velocity, w = pad
};

StructuredBuffer<PointData> _PointsRead;
RWStructuredBuffer<PointData> _PointsWrite;
int _PointCount;

float4 InsideColor;
float4 OutsideColor;

float3 _ControlPointPos;

float4x4 _CamFrustum;   // rows: 0=TL,1=TR,2=BR,3=BL (as your C# builds it)
float4x4 _CamToWorld;   // camera to world matrix
float3 _CameraPos;
float _MaxDistance;

TextureCube<float4> _SkyBoxCubeMap;
SamplerState _LinearClamp; // Or other sampler state

RWTexture2D<float4> _Result; // output
float2 _Resolution;          // width, height (set from C#)

float time;

float totalChainLength;

//===================
// Helper functions
//===================

float myInverseLerp(float a, float b, float t)
{
    return saturate((t-a)/(b-a));
}

// from: https://iquilezles.org/articles/smoothsteps/
float smoothstep( float x )
{
  return x*x*(2.0-x*x);
}

//===================
// Distance functions
//===================

float sdSphere(float3 p, float s)
{
    return length(p) - s;
}

float sdCapsule(float3 p, float3 a, float3 b, float ra, float rb)
{
    float3 pa = p-a;
    float3 ba = b-a;
    float h = saturate(dot(pa, ba)/dot(ba, ba)); //the h value is like an inverse lerp from 0 to 1 across the length of the cylinder
    float r = lerp(ra, rb, h);
    float d = length(pa - ba * h) - r;
    
    return d;
}

float smoothUnion(float distA, float distB, float strength)
{
    float h = clamp(0.5 + 0.5 * (distB - distA) / strength, 0.0, 1.0);
    return lerp(distB, distA, h) - strength * h * (1.0 - h);
}

float opUnion(float distA, float distB) // not sure why this isnt working
{
    return min(distA, distB);
}

float distanceField(float3 p)
{
    float d = 1e6;

    if(_PointCount == 1) d = sdSphere(p - _PointsRead[0].pointPos_Radius.xyz, _PointsRead[0].pointPos_Radius.w);

    if(_PointCount > 1)
    {
        for (int i = _PointCount - 1; i > 0 ; i--)
        {
            float3 pos = _PointsRead[i].pointPos_Radius.xyz;
            float rad = _PointsRead[i].pointPos_Radius.w;
            
            float sphere = sdSphere(p - pos, rad);
            // adding inbetween sphere
            float3 diffBetween = _PointsRead[i-1].pointPos_Radius.xyz - _PointsRead[i].pointPos_Radius.xyz;
            float betweenDist = length(diffBetween) * 0.5;
            float3 dirToBetween = normalize(diffBetween); // this is FROM the leading point TO the following point
            float3 betweenPos = _PointsRead[i].pointPos_Radius.xyz + dirToBetween * betweenDist;
            float avScale = (rad + _PointsRead[i-1].pointPos_Radius.w) * 0.5;
            float betweenSphere = sdSphere(p - betweenPos, avScale);
            //adding the inbetween sphere:
            sphere = smoothUnion(sphere, betweenSphere, avScale  * 1.0);

            d = smoothUnion(d, sphere, rad  * 1.0);
        }
    }

    return d;
}

float3 getNormal(float3 p)
{
    const float2 e = float2(0.001, 0);
    float3 n = float3(
        distanceField(p + e.xyy) - distanceField(p - e.xyy),
        distanceField(p + e.yxy) - distanceField(p - e.yxy),
        distanceField(p + e.yyx) - distanceField(p - e.yyx)
    );
    return normalize(n);
}

float fresnel(float3 n, float3 rd)
{
    float d = 1 - saturate(abs(dot(n, rd)));
    return d;
}

//======================
// Point Update Kernel (for fluid relationships between points)
//======================

[numthreads(64,1,1)]
void UpdatePoints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _PointCount) return;

    PointData p = _PointsRead[i];

    if (i == _PointCount-1) // this is currently the Control Point
    {
        p.pointPos_Radius.xyz = lerp(p.pointPos_Radius.xyz, _ControlPointPos, time * 10.0);
    }

    if(i < _PointCount - 1)
    {
        // === VELOCITY ===
        //1. calculate new velocity
        //2. write/store new velocity 
        //3. read old velocity, update current position
        
        //1.
        PointData target = _PointsRead[i+1]; 
        float3 diff = target.pointPos_Radius.xyz - p.pointPos_Radius.xyz; // direction TO the target, so this takes care of the negative in -k * x
        
        float restlength = target.pointPos_Radius.w * 0.8; // a little bit inside the radius, can adjust this
        
        float extention = length(diff) - restlength;
        float3 dir = normalize(diff);
        float k = 0.005; // the constant, can adjust this
        float3 force = dir * k * extention;
        
        float maxDist = (p.pointPos_Radius.w + target.pointPos_Radius.w);
        if(length(diff) > maxDist) // clamping to the max allowed distance
        {
            p.pointPos_Radius.xyz = target.pointPos_Radius.xyz - dir * maxDist;
        }
        
        //2.
        float3 oldVelocity = p.pointVelocity_pad.xyz;
        float3 newVelocity = oldVelocity + force; // unsure this is correct  ***

        // -- gravity ?
        //newVelocity += float3(0.0, time * -0.05, 0.0);

        newVelocity *= 0.96;
        //3.
        p.pointPos_Radius.xyz += oldVelocity; //add old velocity first before updating new velocity *..
        p.pointVelocity_pad.xyz = newVelocity; // ..* this will be written/stored for the next frame
        
        // === SCALE ===
        //1. Curve Falloff towards "tail" (0 to 1 from tail to head)
        //2. Parabolic curve accross length *** STILL HAVENT FIGURED THIS OUT, AS THE TOTAL LENGTH UPDATES DYNAMICALLY
        PointData headPoint = _PointsRead[_PointCount - 1];
        float3 headPos = headPoint.pointPos_Radius.xyz;
        float headRadius = headPoint.pointPos_Radius.w;
        float distFromHead = length(headPos - p.pointPos_Radius.xyz) - headRadius;
        float invLerpedFactor = myInverseLerp(restlength, headRadius * _PointCount, distFromHead);
        invLerpedFactor = pow(invLerpedFactor, 2);

        p.pointPos_Radius.w = headRadius * (1-invLerpedFactor);
    }

    _PointsWrite[i] = p;
}

//================
// Visual Rendering Kernel
//================

float4 Raymarch(float3 ro, float3 rd, float side) // the raymarch returns a position value xyz and a distance value w //"side" is for outside 1 inside -1
{
    const int MAX_STEPS = 128;
    float t = 0.0;

    float d = 0.001;
    float3 p = ro;

    for (int i = 0; i < MAX_STEPS; i++)
    {
        if (t > _MaxDistance) 
        {
            d = _MaxDistance;
            break;
        }

        p = ro + rd * t; // ray origin + ray direction * t
        d = distanceField(p) * side;

        // Avoid infinite loop if distanceField returns negative or zero unexpectedly.
        t += max(d, 1e-5);
    }
    return float4(p, d);
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // bounds check using resolution passed from C#
    if (id.x >= (uint)_Resolution.x || id.y >= (uint)_Resolution.y) return;

    // pixel-centered UV [0..1]
    float2 pixel = float2(id.xy) + 0.5;
    float2 uv = pixel / _Resolution;

    // flip Y because RWTexture2D indexing is origin top-left vs UV origin bottom-left
    uv.y = 1.0 - uv.y;

    // Interpolate ray direction across the frustum corners
    // read frustum rows (each row is a float4 where .xyz is a direction)
    float3 TL = _CamFrustum[0].xyz;
    float3 TR = _CamFrustum[1].xyz;
    float3 BR = _CamFrustum[2].xyz;
    float3 BL = _CamFrustum[3].xyz;

    // Interpolate horizontally across top and bottom, then vertically between them
    float3 top = lerp(TL, TR, uv.x);
    float3 bottom = lerp(BL, BR, uv.x);
    float3 rayView = lerp(top, bottom, uv.y);

    // Normalize and transform direction to world space
    rayView = normalize(rayView);
    float3 rayOrigin = _CameraPos;
    float3 rayDir = normalize( mul(_CamToWorld, float4(rayView, 0)).xyz );

    float3 bgColor = _SkyBoxCubeMap.SampleLevel(_LinearClamp, rayDir, 0);

    // Raymarch
    float3 col = float3(0,0,0);

    float4 rayReturn = Raymarch(rayOrigin, rayDir, 1.0); // the raymarch returns a position value xyz and a distance value w
    float3 p = rayReturn.xyz;
    float dist = rayReturn.w;

    if(dist >= _MaxDistance) col = bgColor;

    if (dist < 0.001)
    {
        float3 n = getNormal(p);
        float f = fresnel(n, rayDir);

        //tint
        float3 col1 = InsideColor.rgb;
        float3 col2 = OutsideColor.rgb;
        float3 gradientCol = lerp(col1, col2, f);

        // reflection
        float3 reflectDir = reflect(rayDir, n);
        float3 reflectCol = _SkyBoxCubeMap.SampleLevel(_LinearClamp, reflectDir, 0);

        // refraction
        float IOR = 1.33;
        float3 enterPoint = p - n * 0.001;
        float3 refractDirEnter = refract(rayDir, n, 1/IOR); // to go from less dense to more dense, use inverse of IOR
        /*
        float4 refractInHit = Raymarch(enterPoint, refractDirEnter, -1.0); // raymarch inside, using -1
        float3 exitPoint = refractInHit.xyz;
        float3 exitNormal = -getNormal(exitPoint);
        float3 refractDirExit = refract(refractDirEnter, exitNormal, IOR); 
        */ 
        // this second, inside to outside refraction is a bit useless in this case, as i have intersecting primitives using smoothunion
        // it would be sweet for a single crystal shape or something, but doesn't add much to this situation

        float3 refractCol = _SkyBoxCubeMap.SampleLevel(_LinearClamp, refractDirEnter, 0);

        // density
        float sphereDiameter = _PointsRead[_PointCount -1].pointPos_Radius.w * 2; // i am using the control sphere diameter as a distance "through" the object
        //float insideDist = refractInHit.w; // the w value stores the distance ** i would use this instead of spherediameter if not for the above stated issue
        float opticalDensity = saturate(exp(-sphereDiameter * 5)); // from this video:https://www.youtube.com/watch?v=0RWaR7zApEo&t=1488s

        float3 reflectRefractCol = lerp(refractCol, reflectCol, f);
        //reflectRefractCol = lerp(reflectRefractCol, col1, opticalDensity);

        //reflectRefractCol = lerp(reflectRefractCol, gradientCol, 0.30);

        float3 mixedCol = reflectRefractCol * gradientCol; // gotta do the tint here correctly, this isn't it

        col = mixedCol;
    }

    _Result[int2(id.xy)] = float4(col, 1.0);
}
